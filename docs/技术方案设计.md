# Email Digest Browser - 技术方案设计

## 1. 项目概述

### 1.1 技术栈
- **应用框架**: Electron 28+
- **前端框架**: React 18 + TypeScript 5
- **构建工具**: Vite 5
- **样式方案**: Tailwind CSS
- **状态管理**: Zustand
- **邮件处理**: nodemailer + imap-simple
- **内容提取**: @mozilla/readability
- **HTTP客户端**: axios
- **打包工具**: electron-builder

### 1.2 项目结构

```
email-digest/
├── src/
│   ├── main/                    # 主进程
│   │   ├── index.ts            # 主进程入口
│   │   ├── preload.ts          # 预加载脚本
│   │   ├── window/             # 窗口管理
│   │   │   ├── mainWindow.ts
│   │   │   └── browserView.ts
│   │   ├── smtp/               # SMTP客户端
│   │   │   ├── SmtpClient.ts
│   │   │   └── types.ts
│   │   ├── imap/               # IMAP客户端
│   │   │   ├── ImapClient.ts
│   │   │   └── parser.ts
│   │   ├── storage/            # 本地存储
│   │   │   ├── FileStorage.ts
│   │   │   └── crypto.ts
│   │   └── llm/                # LLM集成
│   │       ├── LlmClient.ts
│   │       └── providers/
│   ├── renderer/               # 渲染进程
│   │   ├── main.tsx           # 渲染进程入口
│   │   ├── App.tsx
│   │   ├── components/        # 组件
│   │   │   ├── Toolbar/
│   │   │   ├── Sidebar/
│   │   │   ├── BrowserView/
│   │   │   └── ...
│   │   ├── pages/             # 页面
│   │   │   ├── Main.tsx
│   │   │   └── Settings.tsx
│   │   ├── stores/            # 状态管理
│   │   │   ├── useAppStore.ts
│   │   │   ├── useDigestStore.ts
│   │   │   └── useSettingsStore.ts
│   │   ├── hooks/             # 自定义Hooks
│   │   └── utils/             # 工具函数
│   └── shared/                # 共享代码
│       ├── types/             # 类型定义
│       ├── utils/             # 工具函数
│       └── constants/         # 常量
├── docs/                      # 文档
├── tests/                     # 测试
├── public/                    # 静态资源
├── assets/                    # 应用资源
└── scripts/                   # 构建脚本
```

## 2. 主进程设计

### 2.1 窗口管理

#### MainWindow
```typescript
// src/main/window/mainWindow.ts
import { BrowserWindow } from 'electron';

export class MainWindow {
  private window: BrowserWindow | null = null;

  create(): void {
    this.window = new BrowserWindow({
      width: 1400,
      height: 900,
      webPreferences: {
        preload: path.join(__dirname, '../preload/index.js'),
        nodeIntegration: false,
        contextIsolation: true,
      },
    });

    // 加载UI
    if (process.env.NODE_ENV === 'development') {
      this.window.loadURL('http://localhost:5173');
    } else {
      this.window.loadFile('dist/renderer/index.html');
    }
  }

  getBrowserView(): BrowserView {
    // 返回用于显示网页的BrowserView
  }
}
```

#### BrowserView 管理
```typescript
// src/main/window/browserView.ts
import { BrowserView } from 'electron';

export class WebBrowserView {
  private view: BrowserView | null = null;

  create(bounds: Rectangle): BrowserView {
    this.view = new BrowserView({
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
      },
    });

    this.view.setBounds(bounds);
    return this.view;
  }

  async extractContent(): Promise<ArticleContent> {
    // 使用Readability提取内容
    const result = await this.view.webContents.executeJavaScript(`
      const { Readability } = require('@mozilla/readability');
      const reader = new Readability(document.cloneNode(true));
      reader.parse();
    `);
    return result;
  }
}
```

### 2.2 SMTP客户端

```typescript
// src/main/smtp/SmtpClient.ts
import nodemailer from 'nodemailer';
import type { SmtpConfig, EmailMessage } from '@shared/types';

export class SmtpClient {
  private transporter: nodemailer.Transporter;

  constructor(config: SmtpConfig) {
    this.transporter = nodemailer.createTransport({
      host: config.host,
      port: config.port,
      secure: config.secure,
      auth: {
        user: config.username,
        pass: config.password,
      },
    });
  }

  async sendEmail(message: EmailMessage): Promise<void> {
    const mailOptions = {
      from: this.config.username,
      to: this.config.username, // 发送给自己
      subject: message.subject,
      html: message.html,
      text: message.text,
    };

    await this.transporter.sendMail(mailOptions);
  }

  async sendDigest(digest: DigestData): Promise<void> {
    // 发送HTML格式的邮件
    await this.sendEmail({
      subject: `[EmailDigest][HTML] ${digest.title} - ${digest.date} - ${digest.id}`,
      html: this.formatHtmlEmail(digest),
    });

    // 发送JSON格式的邮件
    await this.sendEmail({
      subject: `[EmailDigest][JSON] ${digest.title} - ${digest.date} - ${digest.id}`,
      text: Buffer.from(JSON.stringify(digest)).toString('base64'),
    });

    // 处理图片（如果有）
    if (digest.images && digest.images.length > 0) {
      await this.sendImages(digest.id, digest.images);
    }
  }

  private async sendImages(parentId: string, images: Image[]): Promise<void> {
    for (let i = 0; i < images.length; i++) {
      const chunks = this.splitImage(images[i], 5 * 1024 * 1024); // 5MB
      for (let j = 0; j < chunks.length; j++) {
        await this.sendEmail({
          subject: `[EmailDigest][IMAGE] ${parentId} - ${i}-${j}`,
          text: chunks[j],
        });
      }
    }
  }
}
```

### 2.3 IMAP客户端

```typescript
// src/main/imap/ImapClient.ts
import ImapSimple from 'imap-simple';
import type { ImapConfig } from '@shared/types';

export class ImapClient {
  private connection: ImapSimple.ImapSimple | null = null;

  async connect(config: ImapConfig): Promise<void> {
    this.connection = await ImapSimple.connect({
      imap: {
        host: config.host,
        port: config.port,
        tls: config.tls,
        user: config.username,
        password: config.password,
      },
    });
  }

  async syncDigests(): Promise<DigestData[]> {
    await this.connection.openBox('INBOX');

    // 搜索EmailDigest相关的邮件
    const searchCriteria = ['ALL', ['SUBJECT', 'EmailDigest']];
    const fetchOptions = {
      bodies: ['HEADER', 'TEXT'],
      markSeen: false,
    };

    const messages = await this.connection.search(searchCriteria, fetchOptions);

    return this.parseMessages(messages);
  }

  private parseMessages(messages: any[]): DigestData[] {
    const digestMap = new Map<string, Partial<DigestData>>();

    for (const message of messages) {
      const subject = message.parts[0].body.subject[0];

      if (subject.includes('[HTML]')) {
        // 解析HTML邮件
        const id = this.extractId(subject);
        const html = message.parts[1].body;
        digestMap.set(id, { ...digestMap.get(id), html });
      } else if (subject.includes('[JSON]')) {
        // 解析JSON邮件
        const id = this.extractId(subject);
        const json = Buffer.from(message.parts[1].body, 'base64').toString();
        const data = JSON.parse(json);
        digestMap.set(id, { ...digestMap.get(id), ...data });
      } else if (subject.includes('[IMAGE]')) {
        // 解析图片邮件
        const [parentId, imageIndex] = this.extractImageInfo(subject);
        // 处理图片数据...
      }
    }

    return Array.from(digestMap.values()) as DigestData[];
  }
}
```

### 2.4 本地存储

```typescript
// src/main/storage/FileStorage.ts
import { promises as fs } from 'fs';
import path from 'path';
import { app } from 'electron';
import crypto from 'crypto';

export class FileStorage {
  private userDataPath: string;
  private encryptionKey: Buffer;

  constructor(pin: string) {
    this.userDataPath = app.getPath('userData');
    this.encryptionKey = this.deriveKey(pin);
  }

  private deriveKey(pin: string): Buffer {
    // 使用PBKDF2派生密钥
    return crypto.pbkdf2Sync(pin, 'salt', 100000, 32, 'sha256');
  }

  async saveConfig(config: UserConfig): Promise<void> {
    const encrypted = this.encrypt(JSON.stringify(config));
    await fs.writeFile(
      path.join(this.userDataPath, 'config', 'user.enc'),
      encrypted
    );
  }

  async loadConfig(): Promise<UserConfig | null> {
    try {
      const encrypted = await fs.readFile(
        path.join(this.userDataPath, 'config', 'user.enc')
      );
      const decrypted = this.decrypt(encrypted);
      return JSON.parse(decrypted);
    } catch {
      return null;
    }
  }

  async cacheDigest(digest: DigestData): Promise<void> {
    const { id, title, summary, tags, createdAt } = digest;
    const metadata = { id, title, summary, tags, createdAt };

    // 仅缓存元数据
    await fs.writeFile(
      path.join(this.userDataPath, 'cache', 'metadata', `${id}.json`),
      JSON.stringify(metadata)
    );
  }

  private encrypt(data: string): Buffer {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', this.encryptionKey, iv);
    const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);
    return Buffer.concat([iv, encrypted]);
  }

  private decrypt(data: Buffer): string {
    const iv = data.slice(0, 16);
    const encrypted = data.slice(16);
    const decipher = crypto.createDecipheriv('aes-256-cbc', this.encryptionKey, iv);
    return decipher.update(encrypted) + decipher.final('utf8');
  }
}
```

### 2.5 LLM集成

```typescript
// src/main/llm/LlmClient.ts
import axios from 'axios';
import type { LlmConfig, LlmResponse } from '@shared/types';

export class LlmClient {
  private config: LlmConfig;

  constructor(config: LlmConfig) {
    this.config = config;
  }

  async generateSummary(content: string): Promise<string> {
    // 处理长文：分段
    const chunks = this.splitContent(content);
    const summaries: string[] = [];

    for (const chunk of chunks) {
      const summary = await this.callApi(chunk);
      summaries.push(summary);
    }

    // 如果有多段，再次合并摘要
    if (summaries.length > 1) {
      return await this.mergeSummaries(summaries);
    }

    return summaries[0];
  }

  private async callApi(content: string): Promise<string> {
    const response = await axios.post(
      this.getApiUrl(),
      {
        model: this.config.model,
        messages: [
          {
            role: 'system',
            content: '你是一个专业的内容摘要助手。请为以下文章生成简洁的中文摘要（约150字）。',
          },
          {
            role: 'user',
            content: content,
          },
        ],
        temperature: 0.7,
      },
      {
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return response.data.choices[0].message.content;
  }

  private splitContent(content: string, maxTokens = 3000): string[] {
    // 简单按字符数分割，实际应该使用tokenizer
    const maxChars = maxTokens * 2; // 粗略估算
    const chunks: string[] = [];

    for (let i = 0; i < content.length; i += maxChars) {
      chunks.push(content.slice(i, i + maxChars));
    }

    return chunks;
  }

  private async mergeSummaries(summaries: string[]): Promise<string> {
    const combined = summaries.join('\n\n');
    return await this.callApi(
      `以下是一篇长文的分段摘要，请将它们合并成一个连贯的总摘要：\n\n${combined}`
    );
  }
}
```

## 3. 渲染进程设计

### 3.1 状态管理

```typescript
// src/renderer/stores/useDigestStore.ts
import { create } from 'zustand';
import type { DigestData } from '@shared/types';

interface DigestStore {
  digests: DigestData[];
  currentDigest: DigestData | null;
  isLoading: boolean;

  loadDigests: () => Promise<void>;
  saveDigest: (digest: DigestData) => Promise<void>;
  syncFromEmail: () => Promise<void>;
  setCurrentDigest: (digest: DigestData | null) => void;
}

export const useDigestStore = create<DigestStore>((set, get) => ({
  digests: [],
  currentDigest: null,
  isLoading: false,

  loadDigests: async () => {
    set({ isLoading: true });
    const digests = await window.electron.loadDigests();
    set({ digests, isLoading: false });
  },

  saveDigest: async (digest: DigestData) => {
    await window.electron.saveDigest(digest);
    set((state) => ({
      digests: [...state.digests, digest],
    }));
  },

  syncFromEmail: async () => {
    set({ isLoading: true });
    const newDigests = await window.electron.syncDigests();
    set((state) => ({
      digests: [...state.digests, ...newDigests],
      isLoading: false,
    }));
  },

  setCurrentDigest: (digest: DigestData | null) => {
    set({ currentDigest: digest });
  },
}));
```

### 3.2 IPC通信

```typescript
// src/main/preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electron', {
  // 文摘操作
  saveDigest: (digest: DigestData) => ipcRenderer.invoke('save-digest', digest),
  loadDigests: () => ipcRenderer.invoke('load-digests'),
  syncDigests: () => ipcRenderer.invoke('sync-digests'),

  // 浏览器操作
  navigateTo: (url: string) => ipcRenderer.send('navigate-to', url),
  extractContent: () => ipcRenderer.invoke('extract-content'),

  // 配置操作
  saveConfig: (config: UserConfig) => ipcRenderer.invoke('save-config', config),
  loadConfig: () => ipcRenderer.invoke('load-config'),

  // LLM操作
  generateSummary: (content: string) => ipcRenderer.invoke('generate-summary', content),
});
```

## 4. 数据流设计

### 4.1 保存文摘流程

```
用户点击保存
    ↓
提取页面内容 (Readability)
    ↓
显示预览对话框
    ↓
用户确认 + 选择生成摘要
    ↓
调用LLM生成摘要 (可选)
    ↓
格式化为HTML和JSON
    ↓
通过SMTP发送邮件 (3封: HTML + JSON + 图片)
    ↓
保存到本地缓存
    ↓
更新UI状态
```

### 4.2 同步流程

```
用户点击同步
    ↓
连接IMAP服务器
    ↓
搜索EmailDigest邮件
    ↓
解析HTML和JSON邮件
    ↓
重组完整的DigestData
    ↓
更新本地缓存
    ↓
刷新UI列表
```

## 5. 安全设计

### 5.1 PIN码加密
- 用户首次启动设置PIN码
- 使用PBKDF2派生加密密钥
- 所有敏感信息使用AES-256-CBC加密
- 支持跨设备同步（需重新输入PIN）

### 5.2 数据隔离
- 主进程和渲染进程严格隔离
- 使用contextBridge暴露API
- 所有IPC通信经过验证

## 6. 性能优化

### 6.1 缓存策略
- 仅缓存元数据和文字内容
- 图片按需从邮箱加载
- 使用虚拟滚动处理大列表

### 6.2 懒加载
- 侧边栏列表使用虚拟滚动
- 图片懒加载
- 按需加载文章详情

## 7. 测试策略

### 7.1 单元测试
- SMTP/IMAP客户端测试
- 加密/解密功能测试
- 内容提取测试

### 7.2 集成测试
- 完整的保存流程测试
- 同步流程测试
- IPC通信测试

### 7.3 E2E测试
- 用户完整操作流程
- 跨平台兼容性测试

---

**文档版本**: v1.0
**创建日期**: 2025-01-16
**状态**: 设计阶段
